#Based on the method proposed by Zhang et al 2013
#(https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3843953/)
library(DynTxRegime) #tutorial here - shiny::runGitHub('DynTxRegimeTutorial','ShupingR')
library(rgenoud)
n = 1000
data <- as.data.frame(generate(n = n))
head(data)
# Define the propensity for treatment model and methods.
moPropen1 <- buildModelObj(model = ~ L1,
solver.method = 'glm',
solver.args = list('family'='binomial'),
predict.method = 'predict.glm',
predict.args = list(type='response'))
moPropen2 <- buildModelObj(model = ~ L2,
solver.method = 'glm',
solver.args = list('family'='binomial'),
predict.method = 'predict.glm',
predict.args = list(type='response'))
moPropen <- list(moPropen1, moPropen2)
# outcome model second stage
### specify the covariates of the main effects component of the outcome regression model
moMain2 <- buildModelObj(model = ~ L1 + A1 + L1:A1 + A2 + L2 + A1:L2 + A2:L2,
solver.method = 'lm')
### specify the covariates of the contrasts component of the outcome regression model
moCont2 <- buildModelObj(model = ~ L2 + A1 + A1:L2 ,
solver.method = 'lm')
# outcome model first stage
moMain1 <- buildModelObj(model = ~ L1 + A1 + L1:A1,
solver.method = 'lm')
moCont1 <- buildModelObj(model = ~ A1 + A1:L1,
solver.method = 'lm')
moMain <- list(moMain1, moMain2)
moCont <- list(moCont1, moCont2)
# regime function second stage
regime2 <- function(eta1, eta2, data) {
tst.newstart <- {as.numeric(I(data$L2 < eta2))}
tst.alrstart <- {as.numeric(I(data$L1 < eta1))}
tst <- {as.numeric(tst.newstart + tst.alrstart) > 0}
rec <- rep(1, nrow(x = data))
rec[!tst] <- 0
return( rec )
}
# regime function first stage
regime1 <- function(eta1, data) {
tst <- {as.numeric(I(data$L1 < eta1))}
rec <- rep(1, nrow(x = data))
rec[!tst] <- 0
return( rec )
}
regimes <- list(regime1, regime2)
#### Analysis using AIPW
fit_AIPW <- optimalSeq(moPropen = moPropen,
moMain = moMain, moCont = NULL,
regimes = regimes,
data = data, response = data$Y, txName = c('A1', 'A2'),
Domains = cbind(rep(100, 3), rep(500, 3)),
pop.size = 1000,
starting.values = rep(300, 3))
#estimated values for eta
regimeCoef(object = fit_AIPW)
########Q and A learning doubly robust #########
################################################
rm(list = ls())
source('simulation_replicate_zhang.R')
#Based on the method proposed by Zhang et al 2013
#(https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3843953/)
library(DynTxRegime) #tutorial here - shiny::runGitHub('DynTxRegimeTutorial','ShupingR')
library(rgenoud)
n = 1000
data <- as.data.frame(generate(n = n))
head(data)
# Define the propensity for treatment model and methods.
moPropen1 <- buildModelObj(model = ~ L1,
solver.method = 'glm',
solver.args = list('family'='binomial'),
predict.method = 'predict.glm',
predict.args = list(type='response'))
moPropen2 <- buildModelObj(model = ~ L2,
solver.method = 'glm',
solver.args = list('family'='binomial'),
predict.method = 'predict.glm',
predict.args = list(type='response'))
moPropen <- list(moPropen1, moPropen2)
# outcome model second stage
### specify the covariates of the main effects component of the outcome regression model
moMain2 <- buildModelObj(model = ~ L1 + A1 + L1:A1 + A2 + L2 + A1:L2 + A2:L2,
solver.method = 'lm')
### specify the covariates of the contrasts component of the outcome regression model
moCont2 <- buildModelObj(model = ~ L2 + A1 + A1:L2 ,
solver.method = 'lm')
# outcome model first stage
moMain1 <- buildModelObj(model = ~ L1 + A1 + L1:A1,
solver.method = 'lm')
moCont1 <- buildModelObj(model = ~ A1 + A1:L1,
solver.method = 'lm')
moMain <- list(moMain1, moMain2)
moCont <- list(moCont1, moCont2)
# regime function second stage
regime2 <- function(eta1, eta2, data) {
tst.newstart <- {as.numeric(I(data$L2 < eta2))}
tst.alrstart <- {as.numeric(I(data$L1 < eta1))}
tst <- {as.numeric(tst.newstart + tst.alrstart) > 0}
rec <- rep(1, nrow(x = data))
rec[!tst] <- 0
return( rec )
}
# regime function first stage
regime1 <- function(eta1, data) {
tst <- {as.numeric(I(data$L1 < eta1))}
rec <- rep(1, nrow(x = data))
rec[!tst] <- 0
return( rec )
}
regimes <- list(regime1, regime2)
#### Analysis using AIPW
fit_AIPW <- optimalSeq(moPropen = moPropen,
moMain = moMain, moCont = NULL,
regimes = regimes,
data = data, response = data$Y, txName = c('A1', 'A2'),
Domains = cbind(rep(100, 3), rep(400, 3)),
pop.size = 1000,
starting.values = rep(200, 3))
#estimated values for eta
regimeCoef(object = fit_AIPW)
########Q and A learning doubly robust #########
################################################
rm(list = ls())
source('simulation_replicate_zhang.R')
#Based on the method proposed by Zhang et al 2013
#(https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3843953/)
library(DynTxRegime) #tutorial here - shiny::runGitHub('DynTxRegimeTutorial','ShupingR')
library(rgenoud)
n = 1000
data <- as.data.frame(generate(n = n))
head(data)
# Define the propensity for treatment model and methods.
moPropen1 <- buildModelObj(model = ~ L1,
solver.method = 'glm',
solver.args = list('family'='binomial'),
predict.method = 'predict.glm',
predict.args = list(type='response'))
moPropen2 <- buildModelObj(model = ~ L2,
solver.method = 'glm',
solver.args = list('family'='binomial'),
predict.method = 'predict.glm',
predict.args = list(type='response'))
moPropen <- list(moPropen1, moPropen2)
# outcome model second stage
### specify the covariates of the main effects component of the outcome regression model
moMain2 <- buildModelObj(model = ~ L1 + A1 + L1:A1 + A2 + L2 + A1:L2 + A2:L2,
solver.method = 'lm')
### specify the covariates of the contrasts component of the outcome regression model
moCont2 <- buildModelObj(model = ~ L2 + A1 + A1:L2 ,
solver.method = 'lm')
# outcome model first stage
moMain1 <- buildModelObj(model = ~ L1 + A1 + L1:A1,
solver.method = 'lm')
moCont1 <- buildModelObj(model = ~ A1 + A1:L1,
solver.method = 'lm')
moMain <- list(moMain1, moMain2)
moCont <- list(moCont1, moCont2)
# regime function second stage
regime2 <- function(eta1, eta2, data) {
tst.newstart <- {as.numeric(I(data$L2 < eta2))}
tst.alrstart <- {as.numeric(I(data$L1 < eta1))}
tst <- {as.numeric(tst.newstart + tst.alrstart) > 0}
rec <- rep(1, nrow(x = data))
rec[!tst] <- 0
return( rec )
}
# regime function first stage
regime1 <- function(eta1, data) {
tst <- {as.numeric(I(data$L1 < eta1))}
rec <- rep(1, nrow(x = data))
rec[!tst] <- 0
return( rec )
}
regimes <- list(regime1, regime2)
#### Analysis using AIPW
fit_AIPW <- optimalSeq(moPropen = moPropen,
moMain = moMain, moCont = NULL,
regimes = regimes,
data = data, response = data$Y, txName = c('A1', 'A2'),
Domains = cbind(rep(100, 3), rep(400, 3)),
pop.size = 1000,
starting.values = rep(250, 3))
#estimated values for eta
regimeCoef(object = fit_AIPW)
########Q and A learning doubly robust #########
################################################
rm(list = ls())
source('simulation_replicate_zhang.R')
#Based on the method proposed by Zhang et al 2013
#(https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3843953/)
library(DynTxRegime) #tutorial here - shiny::runGitHub('DynTxRegimeTutorial','ShupingR')
library(rgenoud)
n = 1000
data <- as.data.frame(generate(n = n))
head(data)
# Define the propensity for treatment model and methods.
moPropen1 <- buildModelObj(model = ~ L1,
solver.method = 'glm',
solver.args = list('family'='binomial'),
predict.method = 'predict.glm',
predict.args = list(type='response'))
moPropen2 <- buildModelObj(model = ~ L2,
solver.method = 'glm',
solver.args = list('family'='binomial'),
predict.method = 'predict.glm',
predict.args = list(type='response'))
moPropen <- list(moPropen1, moPropen2)
# outcome model second stage
### specify the covariates of the main effects component of the outcome regression model
moMain2 <- buildModelObj(model = ~ L1 + A1 + L1:A1 + A2 + L2 + A1:L2 + A2:L2,
solver.method = 'lm')
### specify the covariates of the contrasts component of the outcome regression model
moCont2 <- buildModelObj(model = ~ L2 + A1 + A1:L2 ,
solver.method = 'lm')
# outcome model first stage
moMain1 <- buildModelObj(model = ~ L1 + A1 + L1:A1,
solver.method = 'lm')
moCont1 <- buildModelObj(model = ~ A1 + A1:L1,
solver.method = 'lm')
moMain <- list(moMain1, moMain2)
moCont <- list(moCont1, moCont2)
# regime function second stage
regime2 <- function(eta1, eta2, data) {
tst.newstart <- {as.numeric(I(data$L2 < eta2))}
tst.alrstart <- {as.numeric(I(data$L1 < eta1))}
tst <- {as.numeric(tst.newstart + tst.alrstart) > 0}
rec <- rep(1, nrow(x = data))
rec[!tst] <- 0
return( rec )
}
# regime function first stage
regime1 <- function(eta1, data) {
tst <- {as.numeric(I(data$L1 < eta1))}
rec <- rep(1, nrow(x = data))
rec[!tst] <- 0
return( rec )
}
regimes <- list(regime1, regime2)
#### Analysis using AIPW
fit_AIPW <- optimalSeq(moPropen = moPropen,
moMain = moMain, moCont = NULL,
regimes = regimes,
data = data, response = data$Y, txName = c('A1', 'A2'),
Domains = cbind(rep(100, 3), rep(360, 3)),
pop.size = 1000,
starting.values = rep(250, 3))
#estimated values for eta
regimeCoef(object = fit_AIPW)
########Q and A learning doubly robust #########
################################################
rm(list = ls())
source('simulation_replicate_zhang.R')
#Based on the method proposed by Zhang et al 2013
#(https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3843953/)
library(DynTxRegime) #tutorial here - shiny::runGitHub('DynTxRegimeTutorial','ShupingR')
library(rgenoud)
n = 1000
data <- as.data.frame(generate(n = n))
head(data)
# Define the propensity for treatment model and methods.
moPropen1 <- buildModelObj(model = ~ L1,
solver.method = 'glm',
solver.args = list('family'='binomial'),
predict.method = 'predict.glm',
predict.args = list(type='response'))
moPropen2 <- buildModelObj(model = ~ L2,
solver.method = 'glm',
solver.args = list('family'='binomial'),
predict.method = 'predict.glm',
predict.args = list(type='response'))
moPropen <- list(moPropen1, moPropen2)
# outcome model second stage
### specify the covariates of the main effects component of the outcome regression model
moMain2 <- buildModelObj(model = ~ L1 + A1 + L1:A1 + A2 + L2 + A1:L2 + A2:L2,
solver.method = 'lm')
### specify the covariates of the contrasts component of the outcome regression model
moCont2 <- buildModelObj(model = ~ L2 + A1 + A1:L2 ,
solver.method = 'lm')
# outcome model first stage
moMain1 <- buildModelObj(model = ~ L1 + A1 + L1:A1,
solver.method = 'lm')
moCont1 <- buildModelObj(model = ~ A1 + A1:L1,
solver.method = 'lm')
moMain <- list(moMain1, moMain2)
moCont <- list(moCont1, moCont2)
# regime function second stage
regime2 <- function(eta1, eta2, data) {
tst.newstart <- {as.numeric(I(data$L2 < eta2))}
tst.alrstart <- {as.numeric(I(data$L1 < eta1))}
tst <- {as.numeric(tst.newstart + tst.alrstart) > 0}
rec <- rep(1, nrow(x = data))
rec[!tst] <- 0
return( rec )
}
# regime function first stage
regime1 <- function(eta1, data) {
tst <- {as.numeric(I(data$L1 < eta1))}
rec <- rep(1, nrow(x = data))
rec[!tst] <- 0
return( rec )
}
regimes <- list(regime1, regime2)
#### Analysis using AIPW
fit_AIPW <- optimalSeq(moPropen = moPropen,
moMain = moMain, moCont = NULL,
regimes = regimes,
data = data, response = data$Y, txName = c('A1', 'A2'),
Domains = cbind(rep(200, 3), rep(800, 3)),
pop.size = 1000,
starting.values = rep(400, 3))
#estimated values for eta
regimeCoef(object = fit_AIPW)
########Q and A learning doubly robust #########
################################################
rm(list = ls())
source('simulation_replicate_zhang.R')
#Based on the method proposed by Zhang et al 2013
#(https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3843953/)
library(DynTxRegime) #tutorial here - shiny::runGitHub('DynTxRegimeTutorial','ShupingR')
library(rgenoud)
n = 1000
data <- as.data.frame(generate(n = n))
head(data)
# Define the propensity for treatment model and methods.
moPropen1 <- buildModelObj(model = ~ L1,
solver.method = 'glm',
solver.args = list('family'='binomial'),
predict.method = 'predict.glm',
predict.args = list(type='response'))
moPropen2 <- buildModelObj(model = ~ L2,
solver.method = 'glm',
solver.args = list('family'='binomial'),
predict.method = 'predict.glm',
predict.args = list(type='response'))
moPropen <- list(moPropen1, moPropen2)
# outcome model second stage
### specify the covariates of the main effects component of the outcome regression model
moMain2 <- buildModelObj(model = ~ L1 + A1 + L1:A1 + A2 + L2 + A1:L2 + A2:L2,
solver.method = 'lm')
### specify the covariates of the contrasts component of the outcome regression model
moCont2 <- buildModelObj(model = ~ L2 + A1 + A1:L2 ,
solver.method = 'lm')
# outcome model first stage
moMain1 <- buildModelObj(model = ~ L1 + A1 + L1:A1,
solver.method = 'lm')
moCont1 <- buildModelObj(model = ~ A1 + A1:L1,
solver.method = 'lm')
moMain <- list(moMain1, moMain2)
moCont <- list(moCont1, moCont2)
# regime function second stage
regime2 <- function(eta2, data) {
#tst.newstart <- {as.numeric(I(data$L2 < eta2))}
#tst.alrstart <- {as.numeric(I(data$L1 < eta1))}
#tst <- {as.numeric(tst.newstart + tst.alrstart) > 0}
tst <- {as.numeric(I(data$L2 < eta2))}
rec <- rep(1, nrow(x = data))
rec[!tst] <- 0
return( rec )
}
# regime function first stage
regime1 <- function(eta1, data) {
tst <- {as.numeric(I(data$L1 < eta1))}
rec <- rep(1, nrow(x = data))
rec[!tst] <- 0
return( rec )
}
regimes <- list(regime1, regime2)
#### Analysis using AIPW
fit_AIPW <- optimalSeq(moPropen = moPropen,
moMain = moMain, moCont = NULL,
regimes = regimes,
data = data, response = data$Y, txName = c('A1', 'A2'),
Domains = cbind(rep(200, 2), rep(800, 2)),
pop.size = 1000,
starting.values = rep(400, 2))
#estimated values for eta
regimeCoef(object = fit_AIPW)
########Q and A learning doubly robust #########
################################################
rm(list = ls())
source('simulation_replicate_zhang.R')
#Based on the method proposed by Zhang et al 2013
#(https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3843953/)
library(DynTxRegime) #tutorial here - shiny::runGitHub('DynTxRegimeTutorial','ShupingR')
library(rgenoud)
n = 1000
data <- as.data.frame(generate(n = n))
head(data)
# Define the propensity for treatment model and methods.
moPropen1 <- buildModelObj(model = ~ L1,
solver.method = 'glm',
solver.args = list('family'='binomial'),
predict.method = 'predict.glm',
predict.args = list(type='response'))
moPropen2 <- buildModelObj(model = ~ L2,
solver.method = 'glm',
solver.args = list('family'='binomial'),
predict.method = 'predict.glm',
predict.args = list(type='response'))
moPropen <- list(moPropen1, moPropen2)
# outcome model second stage
### specify the covariates of the main effects component of the outcome regression model
moMain2 <- buildModelObj(model = ~ L1 + A1 + L1:A1 + A2 + L2 + A1:L2 + A2:L2,
solver.method = 'lm')
### specify the covariates of the contrasts component of the outcome regression model
moCont2 <- buildModelObj(model = ~ L2 + A1 + A1:L2 ,
solver.method = 'lm')
# outcome model first stage
moMain1 <- buildModelObj(model = ~ L1 + A1 + L1:A1,
solver.method = 'lm')
moCont1 <- buildModelObj(model = ~ A1 + A1:L1,
solver.method = 'lm')
moMain <- list(moMain1, moMain2)
moCont <- list(moCont1, moCont2)
# regime function second stage
regime2 <- function(eta2, data) {
#tst.newstart <- {as.numeric(I(data$L2 < eta2))}
#tst.alrstart <- {as.numeric(I(data$L1 < eta1))}
#tst <- {as.numeric(tst.newstart + tst.alrstart) > 0}
tst <- {as.numeric(I(data$L2 < eta2))}
rec <- rep(1, nrow(x = data))
rec[!tst] <- 0
return( rec )
}
# regime function first stage
regime1 <- function(eta1, data) {
tst <- {as.numeric(I(data$L1 < eta1))}
rec <- rep(1, nrow(x = data))
rec[!tst] <- 0
return( rec )
}
regimes <- list(regime1, regime2)
#### Analysis using AIPW
fit_AIPW <- optimalSeq(moPropen = moPropen,
moMain = moMain, moCont = NULL,
regimes = regimes,
data = data, response = data$Y, txName = c('A1', 'A2'),
Domains = cbind(rep(200, 2), rep(400, 2)),
pop.size = 1000,
starting.values = rep(250, 2))
#estimated values for eta
regimeCoef(object = fit_AIPW)
########Q and A learning doubly robust #########
################################################
rm(list = ls())
source('simulation_replicate_zhang.R')
#Based on the method proposed by Zhang et al 2013
#(https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3843953/)
library(DynTxRegime) #tutorial here - shiny::runGitHub('DynTxRegimeTutorial','ShupingR')
library(rgenoud)
n = 1000
data <- as.data.frame(generate(n = n))
head(data)
# Define the propensity for treatment model and methods.
moPropen1 <- buildModelObj(model = ~ L1,
solver.method = 'glm',
solver.args = list('family'='binomial'),
predict.method = 'predict.glm',
predict.args = list(type='response'))
moPropen2 <- buildModelObj(model = ~ L2,
solver.method = 'glm',
solver.args = list('family'='binomial'),
predict.method = 'predict.glm',
predict.args = list(type='response'))
moPropen <- list(moPropen1, moPropen2)
# outcome model second stage
### specify the covariates of the main effects component of the outcome regression model
moMain2 <- buildModelObj(model = ~ L1 + A1 + L1:A1 + A2 + L2 + A1:L2 + A2:L2,
solver.method = 'lm')
### specify the covariates of the contrasts component of the outcome regression model
moCont2 <- buildModelObj(model = ~ L2 + A1 + A1:L2 ,
solver.method = 'lm')
# outcome model first stage
moMain1 <- buildModelObj(model = ~ L1 + A1 + L1:A1,
solver.method = 'lm')
moCont1 <- buildModelObj(model = ~ A1 + A1:L1,
solver.method = 'lm')
moMain <- list(moMain1, moMain2)
moCont <- list(moCont1, moCont2)
# regime function second stage
regime2 <- function(eta2, data) {
#tst.newstart <- {as.numeric(I(data$L2 < eta2))}
#tst.alrstart <- {as.numeric(I(data$L1 < eta1))}
#tst <- {as.numeric(tst.newstart + tst.alrstart) > 0}
tst <- {as.numeric(I(data$L2 < eta2))}
rec <- rep(1, nrow(x = data))
rec[!tst] <- 0
return( rec )
}
# regime function first stage
regime1 <- function(eta1, data) {
tst <- {as.numeric(I(data$L1 < eta1))}
rec <- rep(1, nrow(x = data))
rec[!tst] <- 0
return( rec )
}
regimes <- list(regime1, regime2)
#### Analysis using AIPW
fit_AIPW <- optimalSeq(moPropen = moPropen,
moMain = moMain, moCont = NULL,
regimes = regimes,
data = data, response = data$Y, txName = c('A1', 'A2'),
Domains = cbind(rep(200, 2), rep(800, 2)),
pop.size = 1000,
starting.values = rep(250, 2))
#estimated values for eta
regimeCoef(object = fit_AIPW)
install.packages("DataCombine")
