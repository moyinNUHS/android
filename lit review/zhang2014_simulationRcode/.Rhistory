}
for (i in 1:niter) {
fit_AIPW[[i]] <- optimalSeq(moPropen =list(p1, p2),
moMain = list(q1Main, q2Main),
moCont = list(q1Cont, q2Cont),
fSet = list(fSet1,fSet2),
regimes = list(regime1, regime2),
data = data, response = data$Y, txName = c('A1', 'A2'),
Domains = rbind(c(200, 300), c(300,400)),
pop.size = 500,
starting.values = c(250, 350))
coeffs[[i]] <-regimeCoef(object = fit_AIPW[[i]])
}
#### Analysis using AIPW
fit_AIPW = list()
coeffs = list()
for (i in 1:niter) {
fit_AIPW[[i]] <- optimalSeq(moPropen =list(p1, p2),
moMain = list(q1Main, q2Main),
moCont = list(q1Cont, q2Cont),
fSet = list(fSet1,fSet2),
regimes = list(regime1, regime2),
data = data_set[[i]], response = data$Y, txName = c('A1', 'A2'),
Domains = rbind(c(200, 300), c(300,400)),
pop.size = 500,
starting.values = c(250, 350))
coeffs[[i]] <-regimeCoef(object = fit_AIPW[[i]])
}
#### Analysis using AIPW
fit_AIPW = list()
coeffs = list()
for (i in 1:niter) {
fit_AIPW[[i]] <- optimalSeq(moPropen =list(p1, p2),
moMain = list(q1Main, q2Main),
moCont = list(q1Cont, q2Cont),
fSet = list(fSet1,fSet2),
regimes = list(regime1, regime2),
data = data_set[[i]], response = data[[i]]$Y, txName = c('A1', 'A2'),
Domains = rbind(c(200, 300), c(300,400)),
pop.size = 500,
starting.values = c(250, 350))
coeffs[[i]] <-regimeCoef(object = fit_AIPW[[i]])
}
coeffs = list()
for (i in 1:niter) {
fit_AIPW[[i]] <- optimalSeq(moPropen =list(p1, p2),
moMain = list(q1Main, q2Main),
moCont = list(q1Cont, q2Cont),
fSet = list(fSet1,fSet2),
regimes = list(regime1, regime2),
data = data_set[[i]], response = data_set[[i]]$Y, txName = c('A1', 'A2'),
Domains = rbind(c(200, 300), c(300,400)),
pop.size = 500,
starting.values = c(250, 350))
coeffs[[i]] <-regimeCoef(object = fit_AIPW[[i]])
}
coeffs
unlist(coeffs)
matrix(coeffs, ncol=2)
str(coeffs)
unlist(coeffs)
as.data.frame(coeffs)
as.data.frame(coeffs, ncol=2)
as.data.frame(unlist(coeffs), ncol=2)
data.frame(unlist(coeffs), ncol=2)
matrix(unlist(coeffs), ncol=2)
matrix(unlist(coeffs), ncol=2, byrow = T)
a = as.data.frame(matrix(unlist(coeffs), ncol=2, byrow = T))
colnames(a) = c('eta1', 'eta2')
a
########Q and A learning doubly robust #########
################################################
rm(list = ls())
source('simulation_replicate_zhang.R')
#Based on the method proposed by Zhang et al 2013
#(https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3843953/)
library(DynTxRegime) #tutorial here - shiny::runGitHub('DynTxRegimeTutorial','ShupingR')
library(rgenoud)
n = 500
niter = 2
data_set = list()
for (i in 1:niter){
data_set[[i]] <- as.data.frame(generate(n = n))
}
head(data)
# Define subsets of patients to limit available treatments
fSet1 <- function(data){
subsets <- list(list("s1",c(0L,1L)))
txOpts <- rep(x = 's1', times = nrow(x = data))
return(list("subsets" = subsets, "txOpts" = txOpts))
}
fSet2 <- function(data){
subsets <- list(list("s1",1L),
list("s2",c(0L,1L)))
txOpts <- rep(x = 's2', times = nrow(x = data))
txOpts[data$A1 == 1L] <- "s1"
return(list("subsets" = subsets, "txOpts" = txOpts))
}
# Define the propensity for treatment model and methods.
p1 <- modelObj::buildModelObj(model = ~ L1,
solver.method = 'glm',
solver.args = list(family='binomial'),
predict.method = 'predict.glm',
predict.args = list(type='response'))
p2 <- modelObj::buildModelObj(model = ~ L2,
solver.method = 'glm',
solver.args = list(family='binomial'),
predict.method = 'predict.glm',
predict.args = list(type='response'))
# outcome model second stage
### specify the covariates of the main effects component of the outcome regression model
q2Main <- modelObj::buildModelObj(model = ~ L1 + L2,
solver.method = 'lm',
predict.method = 'predict.lm')
### specify the covariates of the contrasts component of the outcome regression model
q2Cont <- modelObj::buildModelObj(model = ~ L2,
solver.method = 'lm',
predict.method = 'predict.lm')
# outcome model first stage
q1Main <- modelObj::buildModelObj(model = ~ L1,
solver.method = 'lm',
predict.method = 'predict.lm')
q1Cont <- modelObj::buildModelObj(model = ~ L1,
solver.method = 'lm',
predict.method = 'predict.lm')
# regime function second stage
regime2 <- function(eta2, data){return(data$A1 + {1L-data$A1}*{data$L2 < eta2}) }
# regime function first stage
regime1 <- function(eta1, data){return(as.integer(x = {data$L1 < eta1})) }
#### Analysis using AIPW
fit_AIPW = list()
coeffs = list()
data_set[[i]]
foo = function (data) { optimalSeq(moPropen =list(p1, p2),
moMain = list(q1Main, q2Main),
moCont = list(q1Cont, q2Cont),
fSet = list(fSet1,fSet2),
regimes = list(regime1, regime2),
data = data, response = data$Y, txName = c('A1', 'A2'),
Domains = rbind(c(200, 300), c(300,400)),
pop.size = 500,
starting.values = c(250, 350))
}
save_runs = mclapply(data_set, foo,  mc.cores = 11)
library(parallel)
save_runs = mclapply(data_set, foo,  mc.cores = 11)
coeffs = list()
for (i in 1:niter){
coeffs[[i]] <-regimeCoef(object = save_runs[[i]])
}
coeffs
########Q and A learning doubly robust #########
################################################
rm(list = ls())
source('simulation_replicate_zhang.R')
#Based on the method proposed by Zhang et al 2013
#(https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3843953/)
library(DynTxRegime) #tutorial here - shiny::runGitHub('DynTxRegimeTutorial','ShupingR')
library(rgenoud)
library(parallel)
n = 500
niter = 10
data_set = list()
for (i in 1:niter){
data_set[[i]] <- as.data.frame(generate(n = n))
}
head(data)
# Define subsets of patients to limit available treatments
fSet1 <- function(data){
subsets <- list(list("s1",c(0L,1L)))
txOpts <- rep(x = 's1', times = nrow(x = data))
return(list("subsets" = subsets, "txOpts" = txOpts))
}
fSet2 <- function(data){
subsets <- list(list("s1",1L),
list("s2",c(0L,1L)))
txOpts <- rep(x = 's2', times = nrow(x = data))
txOpts[data$A1 == 1L] <- "s1"
return(list("subsets" = subsets, "txOpts" = txOpts))
}
# Define the propensity for treatment model and methods.
p1 <- modelObj::buildModelObj(model = ~ L1,
solver.method = 'glm',
solver.args = list(family='binomial'),
predict.method = 'predict.glm',
predict.args = list(type='response'))
p2 <- modelObj::buildModelObj(model = ~ L2,
solver.method = 'glm',
solver.args = list(family='binomial'),
predict.method = 'predict.glm',
predict.args = list(type='response'))
# outcome model second stage
### specify the covariates of the main effects component of the outcome regression model
q2Main <- modelObj::buildModelObj(model = ~ L1 + L2,
solver.method = 'lm',
predict.method = 'predict.lm')
### specify the covariates of the contrasts component of the outcome regression model
q2Cont <- modelObj::buildModelObj(model = ~ L2,
solver.method = 'lm',
predict.method = 'predict.lm')
# outcome model first stage
q1Main <- modelObj::buildModelObj(model = ~ L1,
solver.method = 'lm',
predict.method = 'predict.lm')
q1Cont <- modelObj::buildModelObj(model = ~ L1,
solver.method = 'lm',
predict.method = 'predict.lm')
# regime function second stage
regime2 <- function(eta2, data){return(data$A1 + {1L-data$A1}*{data$L2 < eta2}) }
# regime function first stage
regime1 <- function(eta1, data){return(as.integer(x = {data$L1 < eta1})) }
#### Analysis using AIPW
foo = function (data) {
optimalSeq(moPropen =list(p1, p2),
moMain = list(q1Main, q2Main),
moCont = list(q1Cont, q2Cont),
fSet = list(fSet1,fSet2),
regimes = list(regime1, regime2),
data = data, response = data$Y, txName = c('A1', 'A2'),
Domains = rbind(c(200, 300), c(650,750)),
pop.size = 500,
starting.values = c(250, 700))
}
save_runs = mclapply(data_set, foo,  mc.cores = 11)
coeffs = list()
for (i in 1:niter){
coeffs[[i]] <-regimeCoef(object = save_runs[[i]])
}
out = as.data.frame(matrix(unlist(coeffs), byrow = T, ncol = 2))
colnames(out) = c('eta1', 'eta2')
out
0.095*0.001/(.95*0.001+0.01*0.999)
0.095*0.001/(.95*0.001+0.01*0.999)
0.95*0.001/(.95*0.001+0.01*0.999)
p_grid <- seq( from=0 , to=1 , length.out=1000 )
prob_p <- rep( 1 , 1000 )
prob_data <- dbinom( 6 , size=9 , prob=p_grid )
posterior <- prob_data * prob_p
posterior <- posterior / sum(posterior)
hist(prob_data)
sum(posterior)
hist(posterior)
max(posterior)
samples <- sample( p_grid , prob=posterior , size=1e4 , replace=TRUE )
plot( samples )
library(rethinking)
dens( samples )
posterior
?dbunom
prob_data
Pr(6, size = 9, prob = 0.01)
dbinom(6, size = 9, prob = 0.01)
dbinom(6, size = 9, prob = 0.99)
dbinom(6, size = 9, prob = 0.7)
dbinom(6, size = 9, prob = 0.8)
prob_p
p_grid <- seq( from=0 , to=1 , length.out=1000 )
prob_p <- rep( 1 , 1000 )
prob_data <- dbinom( 6 , size=9 , prob=p_grid )
posterior <- prob_data * prob_p
posterior <- posterior / sum(posterior)
head(posterior)
head(prob_data)
dens(posterior)
plot(posterior, p_grid)
plot(y = posterior, x = p_grid)
########Q and A learning doubly robust #########
################################################
rm(list = ls())
source('simulation_replicate_zhang.R')
#Based on the method proposed by Zhang et al 2013
#(https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3843953/)
library(DynTxRegime) #tutorial here - shiny::runGitHub('DynTxRegimeTutorial','ShupingR')
library(rgenoud)
library(parallel)
n = 500
niter = 10
data_set = list()
for (i in 1:niter){
data_set[[i]] <- as.data.frame(generate(n = n))
}
head(data)
# Define subsets of patients to limit available treatments
fSet1 <- function(data){
subsets <- list(list("s1",c(0L,1L)))
txOpts <- rep(x = 's1', times = nrow(x = data))
return(list("subsets" = subsets, "txOpts" = txOpts))
}
fSet2 <- function(data){
subsets <- list(list("s1",1L),
list("s2",c(0L,1L)))
txOpts <- rep(x = 's2', times = nrow(x = data))
txOpts[data$A1 == 1L] <- "s1"
return(list("subsets" = subsets, "txOpts" = txOpts))
}
# Define the propensity for treatment model and methods.
p1 <- modelObj::buildModelObj(model = ~ L1,
solver.method = 'glm',
solver.args = list(family='binomial'),
predict.method = 'predict.glm',
predict.args = list(type='response'))
p2 <- modelObj::buildModelObj(model = ~ L2,
solver.method = 'glm',
solver.args = list(family='binomial'),
predict.method = 'predict.glm',
predict.args = list(type='response'))
# outcome model second stage
q2Main <- buildModelObjSubset(model = ~ L1 + A1 + L1:A1 + I((1-A1)*L2) + I((1-A1)*A2) + I((1-A1)*L2):A2,
solver.method = 'lm',
predict.method = 'predict.lm', dp = 2, subset = "s1,s2")
q2Cont <- NULL
q1Main <- buildModelObjSubset(model = ~ L1 + A1 + A1:L1,
solver.method = 'lm',
predict.method = 'predict.lm', dp = 1, subset = "s1")
q1Cont <- NULL
# regime function second stage
regime2 <- function(eta2, data){return(data$A1 + {1L-data$A1}*{data$L2 < eta2}) }
# regime function first stage
regime1 <- function(eta1, data){return(as.integer(x = {data$L1 < eta1})) }
#### Analysis using AIPW
foo = function (data) {
optimalSeq(moPropen =list(p1, p2),
moMain = list(q1Main, q2Main),
moCont = list(q1Cont, q2Cont),
fSet = list(fSet1,fSet2),
regimes = list(regime1, regime2),
data = data, response = data$Y, txName = c('A1', 'A2'),
Domains = rbind(c(200, 300), c(650,750)),
pop.size = 500,
starting.values = c(250, 700))
}
save_runs = mclapply(data_set, foo,  mc.cores = 11)
coeffs = list()
for (i in 1:niter){
coeffs[[i]] <-regimeCoef(object = save_runs[[i]])
}
out = as.data.frame(matrix(unlist(coeffs), byrow = T, ncol = 2))
colnames(out) = c('eta1', 'eta2')
#### Analysis using AIPW
foo = function (data) {
optimalSeq(moPropen =list(p1, p2),
moMain = list(q1Main, q2Main),
moCont = list(q1Cont, q2Cont),
fSet = list(fSet1,fSet2),
regimes = list(regime1, regime2),
data = data, response = data$Y, txName = c('A1', 'A2'),
Domains = rbind(c(200, 300), c(650,750)),
pop.size = 500,
starting.values = c(250, 700))
}
save_runs = mclapply(data_set, foo,  mc.cores = 11)
#### Analysis using AIPW
foo = function (data) {
optimalSeq(moPropen =list(p1, p2),
moMain = list(q1Main, q2Main),
moCont = NULL,
fSet = list(fSet1,fSet2),
regimes = list(regime1, regime2),
data = data, response = data$Y, txName = c('A1', 'A2'),
Domains = rbind(c(200, 300), c(650,750)),
pop.size = 500,
starting.values = c(250, 700))
}
save_runs = mclapply(data_set, foo,  mc.cores = 11)
coeffs = list()
for (i in 1:niter){
coeffs[[i]] <-regimeCoef(object = save_runs[[i]])
}
out = as.data.frame(matrix(unlist(coeffs), byrow = T, ncol = 2))
colnames(out) = c('eta1', 'eta2')
out
########Q and A learning doubly robust #########
################################################
rm(list = ls())
source('simulation_replicate_zhang.R')
#Based on the method proposed by Zhang et al 2013
#(https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3843953/)
library(DynTxRegime) #tutorial here - shiny::runGitHub('DynTxRegimeTutorial','ShupingR')
library(rgenoud)
library(parallel)
n = 500
niter = 10
data_set = list()
for (i in 1:niter){
data_set[[i]] <- as.data.frame(generate(n = n))
}
head(data)
# Define subsets of patients to limit available treatments
# fSet1 <- function(data){
#   subsets <- list(list("s1",c(0L,1L)))
#
#   txOpts <- rep(x = 's1', times = nrow(x = data))
#
#   return(list("subsets" = subsets, "txOpts" = txOpts))
# }
#
# fSet2 <- function(data){
#   subsets <- list(list("s1",1L),
#                   list("s2",c(0L,1L)))
#
#   txOpts <- rep(x = 's2', times = nrow(x = data))
#   txOpts[data$A1 == 1L] <- "s1"
#
#   return(list("subsets" = subsets, "txOpts" = txOpts))
# }
# Define the propensity for treatment model and methods.
p1 <- modelObj::buildModelObj(model = ~ L1,
solver.method = 'glm',
solver.args = list(family='binomial'),
predict.method = 'predict.glm',
predict.args = list(type='response'))
p2 <- modelObj::buildModelObj(model = ~ L2,
solver.method = 'glm',
solver.args = list(family='binomial'),
predict.method = 'predict.glm',
predict.args = list(type='response'))
# outcome model second stage
q2Main <- buildModelObjSubset(model = ~ L1 + A1 + L1:A1 + I((1-A1)*L2) + I((1-A1)*A2) + I((1-A1)*L2):A2,
solver.method = 'lm',
predict.method = 'predict.lm', dp = 2, subset = "s1,s2")
q2Cont <- NULL
q1Main <- buildModelObjSubset(model = ~ L1 + A1 + A1:L1,
solver.method = 'lm',
predict.method = 'predict.lm', dp = 1, subset = "s1")
q1Cont <- NULL
# regime function second stage
regime2 <- function(eta2, data){return(data$A1 + {1L-data$A1}*{data$L2 < eta2})}
# regime function first stage
regime1 <- function(eta1, data){return(as.integer(x = {data$L1 < eta1})) }
#### Analysis using AIPW
foo = function (data) {
optimalSeq(moPropen =list(p1, p2),
moMain = list(q1Main, q2Main),
moCont = NULL,
#fSet = list(fSet1,fSet2),
regimes = list(regime1, regime2),
data = data, response = data$Y, txName = c('A1', 'A2'),
Domains = rbind(c(200, 300), c(650,750)),
pop.size = 500,
starting.values = c(250, 700))
}
save_runs = mclapply(data_set, foo,  mc.cores = 11)
coeffs = list()
for (i in 1:niter){
coeffs[[i]] <-regimeCoef(object = save_runs[[i]])
}
out = as.data.frame(matrix(unlist(coeffs), byrow = T, ncol = 2))
colnames(out) = c('eta1', 'eta2')
out
########Q and A learning doubly robust #########
################################################
rm(list = ls())
source('simulation_replicate_zhang.R')
#Based on the method proposed by Zhang et al 2013
#(https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3843953/)
library(DynTxRegime) #tutorial here - shiny::runGitHub('DynTxRegimeTutorial','ShupingR')
library(rgenoud)
library(parallel)
n = 500
niter = 10
data_set = list()
for (i in 1:niter){
data_set[[i]] <- as.data.frame(generate(n = n))
}
head(data)
# Define the propensity for treatment model and methods.
p1 <- modelObj::buildModelObj(model = ~ L1,
solver.method = 'glm',
solver.args = list(family='binomial'),
predict.method = 'predict.glm',
predict.args = list(type='response'))
p2 <- modelObj::buildModelObj(model = ~ L2,
solver.method = 'glm',
solver.args = list(family='binomial'),
predict.method = 'predict.glm',
predict.args = list(type='response'))
# outcome model second stage
q2Main <- buildModelObjSubset(model = ~ L1 + A1 + L1:A1 + I((1-A1)*L2) + I((1-A1)*A2) + I((1-A1)*L2):A2,
solver.method = 'lm',
predict.method = 'predict.lm', dp = 2, subset = "s1,s2")
q2Cont <- NULL
q1Main <- buildModelObjSubset(model = ~ L1 + A1 + A1:L1,
solver.method = 'lm',
predict.method = 'predict.lm', dp = 1, subset = "s1")
q1Cont <- NULL
# regime function second stage
regime2 <- function(eta2, data){return(data$A1 + {1L-data$A1}*{data$L2 < eta2})}
# regime function first stage
regime1 <- function(eta1, data){return(as.integer(x = {data$L1 < eta1})) }
#### Analysis using AIPW
foo = function (data) {
optimalSeq(moPropen =list(p1, p2),
moMain = list(q1Main, q2Main),
moCont = NULL,
#fSet = list(fSet1,fSet2),
regimes = list(regime1, regime2),
data = data, response = data$Y, txName = c('A1', 'A2'),
Domains = rbind(c(200, 300), c(650,750)),
pop.size = 500,
starting.values = c(250, 700))
}
save_runs = mclapply(data_set, foo,  mc.cores = 11)
data <- data_set[[1]]
optimalSeq(moPropen =list(p1, p2),
moMain = list(q1Main, q2Main),
moCont = NULL,
#fSet = list(fSet1,fSet2),
regimes = list(regime1, regime2),
data = data, response = data$Y, txName = c('A1', 'A2'),
Domains = rbind(c(200, 300), c(650,750)),
pop.size = 500,
starting.values = c(250, 700))
